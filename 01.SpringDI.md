# 질문: Spring DI 에 대해서 설명하고, IoC와 어떤 관련이 있는지 설명하시오

## Q01. IoC와 DI의 차이점 알아보기 

### IoC (Inversion of Control) - 제어의 역전

**개념:**
- IoC는 객체의 생성과 의존성 관리를 개발자가 직접 하지 않고, 외부의 컨테이너가 담당하는 디자인 패턴입니다.
- 기존에는 개발자가 직접 객체를 생성하고 의존성을 주입했지만, IoC에서는 이 제어권이 프레임워크나 컨테이너로 넘어갑니다.

**핵심 원리:**
- **제어의 역전**: 객체의 생성, 생명주기, 의존성 관리의 제어권이 개발자에서 프레임워크로 역전
- **느슨한 결합(Loose Coupling)**: 객체 간의 의존성을 줄여 유연성과 재사용성 향상
- **의존성 분리**: 객체가 자신이 필요로 하는 의존성을 직접 생성하지 않고 외부에서 제공받음

**예시:**
```java
// IoC 적용 전 - 개발자가 직접 제어
public class UserService {
    private UserRepository userRepository;
    
    public UserService() {
        this.userRepository = new UserRepository(); // 직접 생성
    }
}

// IoC 적용 후 - 컨테이너가 제어
@Component
public class UserService {
    private UserRepository userRepository;
    
    @Autowired
    public UserService(UserRepository userRepository) { // 외부에서 주입
        this.userRepository = userRepository;
    }
}
```

### IoC 없이 직접 객체를 생성하고 관리할 때의 문제점

1. **강한 결합(Strong Coupling)**
   - 객체가 직접 다른 객체를 생성하면, 두 객체 간의 결합도가 높아집니다.
   - 변경이 발생할 때(예: UserRepository를 MemoryUserRepository에서 JdbcUserRepository로 교체) UserService 코드도 함께 수정해야 합니다.

2. **유지보수성 저하**
   - 의존 객체가 많아질수록 생성자나 메서드에서 직접 객체를 생성하고 관리하는 코드가 복잡해집니다.
   - 코드 수정 시 여러 부분을 동시에 변경해야 하므로 유지보수가 어렵습니다.

3. **테스트의 어려움**
   - 테스트 시 Mock 객체나 Stub 객체로 대체하기가 어렵습니다.
   - UserService가 내부에서 직접 UserRepository를 생성하면, 테스트 환경에서 가짜 객체로 바꿔치기 할 수 없습니다.

4. **확장성 및 유연성 저하**
   - 새로운 기능 추가나 변경이 필요할 때, 객체 생성 코드를 일일이 수정해야 하므로 확장성이 떨어집니다.
   - 다양한 구현체를 상황에 따라 주입하기 어렵습니다.

5. **재사용성 감소**
   - 객체가 특정 구현체에 의존하게 되어, 재사용성이 떨어집니다.
   - 동일한 비즈니스 로직을 다른 환경이나 조건에서 재사용하기 어렵습니다.

**정리:**  
직접 객체를 생성하고 관리하면 코드가 복잡해지고, 결합도가 높아지며, 테스트와 유지보수가 어려워집니다. 이러한 문제를 해결하기 위해 IoC와 DI가 도입되었습니다.


### DI (Dependency Injection) - 의존성 주입

**개념:**
- DI는 IoC를 구현하는 구체적인 방법 중 하나입니다.
- 객체가 필요로 하는 의존성을 외부에서 주입받는 방식으로, 객체 간의 결합도를 낮추고 유연성을 높입니다.

**주입 방식:**
1. **생성자 주입 (Constructor Injection)**
   ```java
   @Component
   public class UserService {
       private final UserRepository userRepository;
       
       public UserService(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

2. **필드 주입 (Field Injection)**
   ```java
   @Component
   public class UserService {
       @Autowired
       private UserRepository userRepository;
   }
   ```

3. **수정자 주입 (Setter Injection)**
   ```java
   @Component
   public class UserService {
       private UserRepository userRepository;
       
       @Autowired
       public void setUserRepository(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

### 생성자 주입 (Constructor Injection)

**장점:**
- **불변성 보장:** 의존성이 `final`로 선언되어, 객체 생성 후 변경이 불가능합니다.
- **테스트 용이:** 생성자를 통해 의존성을 주입하므로, 테스트 시 Mock 객체를 쉽게 주입할 수 있습니다.
- **순환 참조 방지:** 순환 참조가 발생하면 애플리케이션 시작 시점에 오류가 발생하여, 문제를 조기에 발견할 수 있습니다.
- **명확한 의존성:** 필요한 의존성이 생성자에 명확하게 드러나 코드의 가독성이 높아집니다.

**단점:**
- **의존성이 많을 때 생성자 길어짐:** 의존성이 많아지면 생성자 파라미터가 길어져 가독성이 떨어질 수 있습니다.

---

#### 필드 주입 (Field Injection)

**장점:**
- **코드 간결:** 별도의 생성자나 setter 메서드 없이 필드에 바로 주입하므로 코드가 간단합니다.
- **빠른 적용:** 기존 코드에 DI를 빠르게 적용할 수 있습니다.

**단점:**
- **테스트 어려움:** 필드가 private이기 때문에 테스트 코드에서 Mock 객체를 주입하기 어렵습니다.
- **불변성 보장 불가:** 객체 생성 후에도 의존성 변경이 가능합니다.
- **명시적 의존성 부족:** 어떤 의존성이 필요한지 클래스 외부에서 바로 알기 어렵습니다.
- **순환 참조 문제:** 순환 참조가 런타임에 발생할 수 있어, 문제를 늦게 발견할 수 있습니다.

---

### 수정자 주입 (Setter Injection)

**장점:**
- **선택적 의존성 주입:** 필수 의존성이 아닌 경우, 필요에 따라 의존성을 주입할 수 있습니다.
- **유연성:** 객체 생성 후에도 의존성을 변경할 수 있습니다.

**단점:**
- **불변성 보장 불가:** setter를 통해 의존성을 언제든 변경할 수 있어, 객체의 상태가 변할 수 있습니다.
- **의존성 누락 위험:** setter 호출을 누락하면 객체가 정상적으로 동작하지 않을 수 있습니다.
- **테스트 시 번거로움:** 테스트 코드에서 setter를 직접 호출해야 하므로 번거로울 수 있습니다.

---

### 주입 방식의 차이점 정리

| 구분 | 생성자 주입 | 필드 주입 | 수정자 주입 |
|------|-------------|-----------|-------------|
| **불변성** | 보장 (final 사용) | 불가 | 불가 |
| **테스트 용이성** | 용이 | 어려움 | 보통 |
| **순환 참조 감지** | 컴파일/런타임 초기에 감지 | 런타임에 감지 | 런타임에 감지 |
| **코드 간결성** | 생성자 코드 필요 | 가장 간결 | setter 메서드 필요 |
| **의존성 명확성** | 명확 | 불명확 | 보통 |
| **선택적 의존성** | 불가 | 가능 | 가능 |
| **실무 권장** | ★★★ (가장 권장) | ★ (권장하지 않음) | ★★ (보조적 사용) |

> **실무에서는 생성자 주입을 가장 권장하며, 필드 주입은 테스트와 유지보수 측면에서 권장하지 않습니다. 선택적 의존성이 필요한 경우에만 수정자 주입을 사용합니다.**


### IoC와 DI의 관계

**관계 설명:**
- **IoC는 원칙(Principle)**: 제어의 역전이라는 디자인 원칙
- **DI는 구현 방법(Implementation)**: IoC 원칙을 구현하는 구체적인 기법
- IoC를 구현하는 방법으로 DI 외에도 Service Locator 패턴 등이 있지만, DI가 가장 널리 사용됨

**Spring에서의 구현:**
- Spring IoC Container가 IoC 원칙을 구현
- @Autowired, @Component 등의 어노테이션을 통해 DI 구현
- ApplicationContext가 IoC 컨테이너 역할을 수행

### IoC와 DI의 차이점 정리

| 구분 | IoC (Inversion of Control) | DI (Dependency Injection) |
|------|---------------------------|---------------------------|
| **정의** | 객체의 생성과 의존성 관리의 제어권이 개발자에서 프레임워크로 역전되는 디자인 패턴 | 객체가 필요로 하는 의존성을 외부에서 주입받는 구체적인 구현 방법 |
| **성격** | 디자인 원칙(Principle) | 구현 기법(Implementation) |
| **범위** | 더 넓은 개념으로 DI를 포함 | IoC를 구현하는 방법 중 하나 |
| **목적** | 객체 간의 결합도를 낮추고 유연성 향상 | 의존성을 외부에서 주입받아 객체 생성과 관리를 분리 |
| **구현 방법** | DI, Service Locator 등 | 생성자, 필드, 수정자 주입 |
| **Spring에서의 역할** | IoC Container가 전체적인 객체 생명주기 관리 | @Autowired 등으로 의존성 주입 구현 |
| **예시** | Spring Container가 객체 생성/관리 | @Component + @Autowired 조합 |

### Spring DI의 장점

1. **느슨한 결합**: 객체 간 의존성이 줄어들어 유연성 향상
2. **테스트 용이성**: Mock 객체 주입으로 단위 테스트 쉬움
3. **재사용성**: 동일한 인터페이스를 구현한 다른 객체로 쉽게 교체 가능
4. **객체 생명주기 관리**: Spring이 객체의 생성과 소멸을 자동 관리
5. **설정의 중앙화**: 의존성 설정을 한 곳에서 관리 

 

## Q02. 스프링에서 사용하는 어노테이션인 @Autowired, @Inject, @Resource 에 대해서 설명하시오.

### A. 의존성 주입 어노테이션 상세 분석

#### @Autowired (Spring 전용)

**개념:**
- Spring Framework에서 제공하는 전용 의존성 주입 어노테이션
- Spring IoC 컨테이너가 자동으로 빈을 찾아서 주입

**주입 방식:**
1. **생성자 주입**
   ```java
   @Component
   public class UserService {
       private final UserRepository userRepository;
       
       @Autowired // 생략 가능 (단일 생성자인 경우)
       public UserService(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

2. **필드 주입**
   ```java
   @Component
   public class UserService {
       @Autowired
       private UserRepository userRepository;
   }
   ```

3. **수정자 주입**
   ```java
   @Component
   public class UserService {
       private UserRepository userRepository;
       
       @Autowired
       public void setUserRepository(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

**주입 옵션:**
```java
// required = false: 의존성이 없어도 에러 발생하지 않음
@Autowired(required = false)
private UserRepository userRepository;

// @Qualifier로 특정 빈 지정
@Autowired
@Qualifier("jdbcUserRepository")
private UserRepository userRepository;
```

**특징:**
- Spring 전용 어노테이션
- 타입 기반 주입 (Type-based injection)
- required 속성으로 필수/선택적 주입 제어
- @Qualifier와 함께 사용하여 특정 빈 지정 가능

---

#### @Inject (JSR-330 표준)

- 참고: JSR(Java Specification Request, 자바 표준 명세를 정의하는 공식 요청서)

**개념:**
- Java 표준 의존성 주입 어노테이션 (JSR-330)
- Spring 외에도 다른 DI 컨테이너에서도 사용 가능
- Spring에서 @Autowired와 동일하게 동작

**주입 방식:**
1. **생성자 주입**
   ```java
   @Component
   public class UserService {
       private final UserRepository userRepository;
       
       @Inject // 생략 불가
       public UserService(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

2. **필드 주입**
   ```java
   @Component
   public class UserService {
       @Inject
       private UserRepository userRepository;
   }
   ```

3. **수정자 주입**
   ```java
   @Component
   public class UserService {
       private UserRepository userRepository;
       
       @Inject
       public void setUserRepository(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

**주입 옵션:**
```java
// @Named으로 특정 빈 지정 (Spring의 @Qualifier와 동일)
@Inject
@Named("jdbcUserRepository")
private UserRepository userRepository;

// Provider<T>로 지연 주입
@Inject
private Provider<UserRepository> userRepositoryProvider;
```

**특징:**
- Java 표준 어노테이션
- Spring과 독립적
- @Named로 특정 빈 지정
- Provider<T>로 지연 주입 지원

---

#### @Resource (JSR-250 표준)

**개념:**
- Java 표준 어노테이션 (JSR-250)
- 이름 기반 주입 (Name-based injection)
- Spring에서 지원하지만 Spring 전용은 아님

**주입 방식:**
```java
@Component
public class UserService {
    // 이름으로 주입 (기본값: 필드명)
    @Resource
    private UserRepository userRepository;
    
    // 특정 이름으로 주입
    @Resource(name = "jdbcUserRepository")
    private UserRepository userRepository;
    
    // 타입으로 주입
    @Resource(type = UserRepository.class)
    private UserRepository userRepository;
}
```

**주입 옵션:**
```java
// name 속성으로 특정 빈 이름 지정
@Resource(name = "jdbcUserRepository")
private UserRepository userRepository;

// type 속성으로 타입 지정
@Resource(type = UserRepository.class)
private UserRepository userRepository;

// 수정자 메서드에 적용
@Resource
public void setUserRepository(UserRepository userRepository) {
    this.userRepository = userRepository;
}
```

**특징:**
- 이름 기반 주입 (기본값: 필드명)
- name, type 속성으로 세밀한 제어
- 생성자 주입 지원하지 않음
- 필드와 수정자 메서드에만 적용 가능

---

#### 어노테이션별 상세 비교

| 구분 | @Autowired | @Inject | @Resource |
|------|------------|---------|-----------|
| **표준** | Spring 전용 | JSR-330 (Java 표준) | JSR-250 (Java 표준) |
| **주입 방식** | 타입 기반 | 타입 기반 | 이름 기반 |
| **생성자 주입** | 지원 (생략 가능) | 지원 (생략 불가) | 지원하지 않음 |
| **필드 주입** | 지원 | 지원 | 지원 |
| **수정자 주입** | 지원 | 지원 | 지원 |
| **필수/선택적** | required 속성 | Provider<T> 사용 | 기본 필수 |
| **특정 빈 지정** | @Qualifier | @Named | name 속성 |
| **지연 주입** | @Lazy | Provider<T> | 지원하지 않음 |
| **Spring 의존성** | 완전 의존 | 독립적 | 독립적 |
| **호환성** | Spring 전용 | 범용 | 범용 |

---

#### 각 어노테이션의 장단점

| 어노테이션 | 장점 | 단점 |
|------------|------|------|
| **@Autowired** | • Spring과 완벽 통합<br>• 간편한 사용법<br>• 생략 가능한 생성자 주입<br>• required 속성으로 유연한 제어<br>• @Qualifier와의 조합 | • Spring에 종속<br>• 다른 DI 컨테이너와 호환성 없음<br>• Spring 생태계 밖에서는 사용 불가 |
| **@Inject** | • Java 표준<br>• Spring 독립적<br>• 다른 DI 컨테이너와 호환<br>• Provider<T>로 지연 주입<br>• 범용성 높음 | • 생성자 주입 시 생략 불가<br>• Spring 특화 기능 부족<br>• @Named 사용 시 코드 복잡성 |
| **@Resource** | • Java 표준<br>• 이름 기반으로 직관적<br>• 세밀한 제어 가능<br>• 범용성 높음 | • 생성자 주입 미지원<br>• 타입 기반 주입 시 제한적<br>• 지연 주입 미지원<br>• Spring 특화 기능 부족 |

---

#### 실무 권장사항

**1. Spring 전용 프로젝트**
- **권장**: @Autowired
- **이유**: Spring과의 완벽한 통합, 간편한 사용법

**2. 범용 라이브러리 개발**
- **권장**: @Inject
- **이유**: Java 표준, 다른 DI 컨테이너와의 호환성

**3. 이름 기반 주입이 필요한 경우**
- **권장**: @Resource
- **이유**: 이름 기반 주입의 직관성

**4. 생성자 주입 시**
- **권장**: @Autowired (생략 가능)
- **이유**: 코드 간결성

**5. 지연 주입이 필요한 경우**
- **권장**: @Inject + Provider<T>
- **이유**: 표준 지연 주입 지원

> **결론**: Spring 프로젝트에서는 @Autowired를 주로 사용하고, 범용 라이브러리나 특별한 요구사항이 있을 때 @Inject나 @Resource를 사용하는 것이 일반적입니다.

