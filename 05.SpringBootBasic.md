# 05. SpringBoot 기본

## Q01. Spring Boot 에서 Filter 의 기능, 정의방법, 사용예 등에 대해서 설명하시오.

### 1. Spring Boot Filter의 개념과 기능

#### 1.1 Filter란?
- **Filter**는 웹 애플리케이션에서 요청과 응답을 가로채서 전처리 또는 후처리를 수행하는 컴포넌트입니다.
- Servlet 2.3부터 도입된 표준 웹 컴포넌트로, Spring Boot에서도 이를 활용합니다.
- 클라이언트의 요청이 서블릿에 도달하기 전과 서블릿의 응답이 클라이언트에 도달하기 전에 처리됩니다.

#### 1.2 Filter의 주요 기능
1. **인증/인가 처리**: 로그인 여부 확인, 권한 검증
2. **로깅**: 요청/응답 정보 기록
3. **인코딩 처리**: 문자 인코딩 설정
4. **CORS 처리**: Cross-Origin Resource Sharing 설정
5. **요청/응답 변환**: 요청 데이터 변환, 응답 데이터 가공
6. **성능 모니터링**: 요청 처리 시간 측정
7. **보안 처리**: XSS 방지, CSRF 토큰 검증

### 2. Filter 정의 방법

#### 2.1 방법 1: Filter 인터페이스 구현
```java
@Component
public class CustomFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain filterChain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        // 전처리 로직
        System.out.println("Filter: " + httpRequest.getRequestURI() + " 요청 처리 시작");
        long startTime = System.currentTimeMillis();
        
        // 다음 필터 또는 서블릿으로 요청 전달
        filterChain.doFilter(request, response);
        
        // 후처리 로직
        long endTime = System.currentTimeMillis();
        System.out.println("Filter: " + httpRequest.getRequestURI() + " 요청 처리 완료 (" + 
                         (endTime - startTime) + "ms)");
    }
    
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 필터 초기화 시 실행
        System.out.println("CustomFilter 초기화");
    }
    
    @Override
    public void destroy() {
        // 필터 소멸 시 실행
        System.out.println("CustomFilter 소멸");
    }
}
```

#### 2.2 방법 2: OncePerRequestFilter 상속 (권장)
```java
@Component
public class LoggingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        // 전처리
        String requestURI = request.getRequestURI();
        String method = request.getMethod();
        
        log.info("=== 요청 시작 ===");
        log.info("URI: {}, Method: {}", requestURI, method);
        
        long startTime = System.currentTimeMillis();
        
        try {
            // 다음 필터 또는 서블릿으로 요청 전달
            filterChain.doFilter(request, response);
        } finally {
            // 후처리
            long endTime = System.currentTimeMillis();
            long duration = endTime - startTime;
            
            log.info("=== 요청 완료 ===");
            log.info("URI: {}, Duration: {}ms, Status: {}", 
                    requestURI, duration, response.getStatus());
        }
    }
    
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        // 특정 경로는 필터링하지 않음
        String path = request.getRequestURI();
        return path.startsWith("/static/") || path.startsWith("/public/");
    }
}
```

#### 2.3 방법 3: FilterRegistrationBean 사용
```java
@Configuration
public class FilterConfig {
    
    @Bean
    public FilterRegistrationBean<CustomFilter> customFilterRegistration() {
        FilterRegistrationBean<CustomFilter> registrationBean = new FilterRegistrationBean<>();
        
        registrationBean.setFilter(new CustomFilter());
        registrationBean.addUrlPatterns("/*"); // 모든 URL에 적용
        registrationBean.setOrder(1); // 필터 순서 설정
        registrationBean.setName("customFilter");
        
        return registrationBean;
    }
}
```

### 3. Filter 사용 예제

#### 3.1 인증 필터 예제
```java
@Component
public class AuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        String token = request.getHeader("Authorization");
        
        // 인증이 필요한 경로인지 확인
        if (isProtectedPath(request.getRequestURI())) {
            if (token == null || !isValidToken(token)) {
                response.setStatus(HttpStatus.UNAUTHORIZED.value());
                response.getWriter().write("인증이 필요합니다.");
                return;
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    private boolean isProtectedPath(String uri) {
        return uri.startsWith("/api/") && !uri.startsWith("/api/public/");
    }
    
    private boolean isValidToken(String token) {
        // 토큰 검증 로직
        return token.startsWith("Bearer ") && token.length() > 10;
    }
}
```

#### 3.2 CORS 필터 예제
```java
@Component
public class CorsFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        response.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
        response.setHeader("Access-Control-Max-Age", "3600");
        
        if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
            response.setStatus(HttpStatus.OK.value());
            return;
        }
        
        filterChain.doFilter(request, response);
    }
}
```

#### 3.3 로깅 필터 예제
```java
@Component
@Slf4j
public class RequestLoggingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        // 요청 정보 로깅
        String requestURI = request.getRequestURI();
        String method = request.getMethod();
        String userAgent = request.getHeader("User-Agent");
        String remoteAddr = request.getRemoteAddr();
        
        log.info("=== 요청 정보 ===");
        log.info("URI: {}", requestURI);
        log.info("Method: {}", method);
        log.info("User-Agent: {}", userAgent);
        log.info("Remote Address: {}", remoteAddr);
        
        long startTime = System.currentTimeMillis();
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            int status = response.getStatus();
            
            log.info("=== 응답 정보 ===");
            log.info("Status: {}", status);
            log.info("Duration: {}ms", duration);
        }
    }
}
```

#### 3.4 인코딩 필터 예제
```java
@Component
public class EncodingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        // 요청 인코딩 설정
        request.setCharacterEncoding("UTF-8");
        
        // 응답 인코딩 설정
        response.setCharacterEncoding("UTF-8");
        response.setContentType("text/html; charset=UTF-8");
        
        filterChain.doFilter(request, response);
    }
}
```

### 4. Filter 순서와 우선순위

#### 4.1 Filter 순서 설정
```java
@Component
@Order(1) // 낮은 숫자가 높은 우선순위
public class FirstFilter extends OncePerRequestFilter {
    // 구현
}

@Component
@Order(2)
public class SecondFilter extends OncePerRequestFilter {
    // 구현
}

@Component
@Order(3)
public class ThirdFilter extends OncePerRequestFilter {
    // 구현
}
```

#### 4.2 FilterRegistrationBean을 통한 순서 설정
```java
@Configuration
public class FilterOrderConfig {
    
    @Bean
    public FilterRegistrationBean<FirstFilter> firstFilter() {
        FilterRegistrationBean<FirstFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new FirstFilter());
        registration.addUrlPatterns("/*");
        registration.setOrder(1);
        return registration;
    }
    
    @Bean
    public FilterRegistrationBean<SecondFilter> secondFilter() {
        FilterRegistrationBean<SecondFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new SecondFilter());
        registration.addUrlPatterns("/*");
        registration.setOrder(2);
        return registration;
    }
}
```

### 5. Filter와 Interceptor의 차이점

| 구분 | Filter | Interceptor |
|------|--------|-------------|
| **위치** | Servlet 전후 | Controller 전후 |
| **스프링 지원** | 표준 서블릿 스펙 | 스프링 프레임워크 |
| **빈 주입** | 불가능 | 가능 |
| **스프링 컨텍스트** | 접근 불가 | 접근 가능 |
| **용도** | 인코딩, CORS, 보안 | 로깅, 인증, 권한 |

### 6. 실제 프로젝트에서의 활용

#### 6.1 보안 필터 체인
```java
@Component
@Order(1)
public class SecurityFilter extends OncePerRequestFilter {
    // 보안 검증
}

@Component
@Order(2)
public class AuthenticationFilter extends OncePerRequestFilter {
    // 인증 처리
}

@Component
@Order(3)
public class AuthorizationFilter extends OncePerRequestFilter {
    // 권한 검증
}
```

#### 6.2 성능 모니터링 필터
```java
@Component
@Slf4j
public class PerformanceFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        long startTime = System.currentTimeMillis();
        long startMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            long endTime = System.currentTimeMillis();
            long endMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
            
            long duration = endTime - startTime;
            long memoryUsed = endMemory - startMemory;
            
            if (duration > 1000) { // 1초 이상 걸린 요청만 로깅
                log.warn("느린 요청 감지: {} {} ({}ms, {}MB)", 
                        request.getMethod(), request.getRequestURI(), duration, memoryUsed / 1024 / 1024);
            }
        }
    }
}
```

### 7. 주의사항과 모범 사례

#### 7.1 주의사항
1. **Filter 순서**: 필터의 실행 순서가 중요하므로 명확히 설정
2. **예외 처리**: Filter에서 발생한 예외는 적절히 처리
3. **성능 고려**: Filter에서 무거운 작업을 수행하지 않도록 주의
4. **메모리 누수**: Filter에서 사용한 리소스는 적절히 해제

#### 7.2 모범 사례
1. **OncePerRequestFilter 사용**: 동일한 요청에 대해 한 번만 실행되도록 보장
2. **명확한 책임 분리**: 각 Filter는 하나의 명확한 책임만 가짐
3. **설정 외부화**: Filter 설정은 application.properties에서 관리
4. **로깅 활용**: Filter 동작을 추적할 수 있도록 적절한 로깅 추가

이러한 방식으로 Spring Boot에서 Filter를 활용하여 웹 애플리케이션의 요청/응답 처리 과정을 효과적으로 제어할 수 있습니다.
