# 08. SpringBoot Handler Adapter

## Q04. Handler Mapping 이후 Handler Adapter 에서 수행할때 처리과정을 설명해줘

### 1. Handler Adapter의 개념과 역할

#### 1.1 Handler Adapter란?
- **Handler Adapter**는 DispatcherServlet에서 Handler(Controller)를 실행하기 위한 어댑터 패턴을 구현한 컴포넌트입니다.
- HandlerMapping이 요청을 처리할 Handler를 찾은 후, Handler Adapter가 실제로 Handler를 실행합니다.
- 다양한 타입의 Handler를 동일한 방식으로 실행할 수 있게 해주는 중간 계층 역할을 합니다.

#### 1.2 Handler Adapter의 위치
```
요청 → DispatcherServlet → HandlerMapping → Handler Adapter → Handler(Controller) → ViewResolver → View
```

#### 1.3 Handler Adapter의 주요 역할
1. **Handler 실행**: Controller 메서드 호출
2. **파라미터 바인딩**: 요청 데이터를 메서드 파라미터로 변환
3. **반환값 처리**: Controller의 반환값을 ModelAndView로 변환
4. **예외 처리**: Handler 실행 중 발생한 예외 처리
5. **응답 생성**: HTTP 응답 생성

### 2. Handler Adapter의 구조와 인터페이스

#### 2.1 HandlerAdapter 인터페이스
```java
public interface HandlerAdapter {
    
    /**
     * 이 어댑터가 주어진 handler를 지원하는지 확인
     */
    boolean supports(Object handler);
    
    /**
     * Handler를 실행하고 ModelAndView를 반환
     */
    ModelAndView handle(HttpServletRequest request, 
                       HttpServletResponse response, 
                       Object handler) throws Exception;
    
    /**
     * 마지막 수정 시간을 반환 (캐싱용)
     */
    long getLastModified(HttpServletRequest request, Object handler);
}
```

#### 2.2 주요 Handler Adapter 구현체들

**1. RequestMappingHandlerAdapter**
- @RequestMapping 어노테이션이 붙은 메서드를 처리
- 가장 일반적으로 사용되는 Handler Adapter

**2. HttpRequestHandlerAdapter**
- HttpRequestHandler 인터페이스를 구현한 클래스 처리

**3. SimpleControllerHandlerAdapter**
- Controller 인터페이스를 구현한 클래스 처리

**4. SimpleServletHandlerAdapter**
- Servlet을 Handler로 사용할 때 처리

### 3. Handler Adapter의 처리 과정

#### 3.1 전체 처리 흐름
```java
// DispatcherServlet의 doDispatch 메서드에서
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    
    // 1. HandlerMapping을 통해 Handler 결정
    HandlerExecutionChain mappedHandler = getHandler(request);
    
    // 2. Handler Adapter 결정
    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
    
    // 3. Interceptor preHandle 실행
    if (!mappedHandler.applyPreHandle(request, response)) {
        return;
    }
    
    // 4. Handler Adapter를 통해 Handler 실행
    ModelAndView mv = ha.handle(request, response, mappedHandler.getHandler());
    
    // 5. Interceptor postHandle 실행
    mappedHandler.applyPostHandle(request, response, mv);
    
    // 6. View 처리 및 응답
    processDispatchResult(request, response, mappedHandler, mv, dispatchException);
}
```

#### 3.2 Handler Adapter 선택 과정
```java
protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
    
    // 등록된 모든 Handler Adapter를 순회
    for (HandlerAdapter ha : this.handlerAdapters) {
        if (ha.supports(handler)) {
            return ha;
        }
    }
    
    throw new ServletException("No adapter for handler [" + handler +
                             "]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler");
}
```

### 4. RequestMappingHandlerAdapter의 상세 처리 과정

#### 4.1 RequestMappingHandlerAdapter의 handle 메서드
```java
@Override
public ModelAndView handle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler) throws Exception {
    
    // 1. Handler 메서드 정보 추출
    HandlerMethod handlerMethod = (HandlerMethod) handler;
    
    // 2. WebDataBinder 생성 및 초기화
    WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
    
    // 3. ModelAttributeMethodProcessor 생성
    ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);
    
    // 4. ServletInvocableHandlerMethod 생성
    ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
    
    // 5. ArgumentResolver 설정
    invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
    
    // 6. ReturnValueHandler 설정
    invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
    
    // 7. DataBinder 설정
    invocableMethod.setDataBinderFactory(binderFactory);
    
    // 8. ParameterNameDiscoverer 설정
    invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
    
    // 9. ModelAndViewContainer 생성
    ModelAndViewContainer mavContainer = new ModelAndViewContainer();
    
    // 10. Model 초기화
    modelFactory.initModel(webRequest, mavContainer, invocableMethod);
    
    // 11. Handler 메서드 실행
    invocableMethod.invokeAndHandle(webRequest, mavContainer);
    
    // 12. ModelAndView 생성 및 반환
    return getModelAndView(mavContainer, modelFactory, webRequest);
}
```

#### 4.2 파라미터 바인딩 과정
```java
// ArgumentResolver를 통한 파라미터 바인딩
public class RequestParamMethodArgumentResolver implements HandlerMethodArgumentResolver {
    
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.hasParameterAnnotation(RequestParam.class);
    }
    
    @Override
    public Object resolveArgument(MethodParameter parameter, 
                                ModelAndViewContainer mavContainer,
                                NativeWebRequest webRequest, 
                                WebDataBinderFactory binderFactory) throws Exception {
        
        // 1. 요청에서 파라미터 값 추출
        String paramName = parameter.getParameterAnnotation(RequestParam.class).value();
        String paramValue = webRequest.getParameter(paramName);
        
        // 2. 타입 변환
        Class<?> paramType = parameter.getParameterType();
        Object convertedValue = convertValue(paramValue, paramType);
        
        return convertedValue;
    }
}
```

#### 4.3 반환값 처리 과정
```java
// ReturnValueHandler를 통한 반환값 처리
public class RequestResponseBodyMethodProcessor implements HandlerMethodReturnValueHandler {
    
    @Override
    public boolean supportsReturnType(MethodParameter returnType) {
        return returnType.hasMethodAnnotation(ResponseBody.class);
    }
    
    @Override
    public void handleReturnValue(Object returnValue, 
                                MethodParameter returnType,
                                ModelAndViewContainer mavContainer, 
                                NativeWebRequest webRequest) throws Exception {
        
        // 1. 반환값을 JSON으로 직렬화
        String json = objectMapper.writeValueAsString(returnValue);
        
        // 2. HTTP 응답 생성
        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");
        response.getWriter().write(json);
        
        // 3. View 렌더링 비활성화
        mavContainer.setRequestHandled(true);
    }
}
```

### 5. 실제 처리 예제

#### 5.1 REST API 요청 처리
```java
// 요청: POST /api/users
// Content-Type: application/json
// Body: {"name": "John", "email": "john@example.com"}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);
    }
}

// Handler Adapter 처리 과정:
// 1. RequestMappingHandlerAdapter가 HandlerMethod 생성
// 2. @RequestBody 어노테이션을 가진 파라미터를 위한 ArgumentResolver 찾기
// 3. JSON 요청 본문을 User 객체로 변환
// 4. Controller 메서드 실행
// 5. ResponseEntity 반환값을 위한 ReturnValueHandler 찾기
// 6. User 객체를 JSON으로 직렬화하여 응답 생성
```

#### 5.2 웹 페이지 요청 처리
```java
// 요청: GET /users/list?page=1&size=10

@Controller
@RequestMapping("/users")
public class UserViewController {
    
    @GetMapping("/list")
    public String listUsers(@RequestParam(defaultValue = "1") int page,
                           @RequestParam(defaultValue = "10") int size,
                           Model model) {
        List<User> users = userService.findUsers(page, size);
        model.addAttribute("users", users);
        return "users/list";
    }
}

// Handler Adapter 처리 과정:
// 1. RequestMappingHandlerAdapter가 HandlerMethod 생성
// 2. @RequestParam 어노테이션을 가진 파라미터들을 위한 ArgumentResolver 찾기
// 3. 요청 파라미터를 int 타입으로 변환
// 4. Controller 메서드 실행
// 5. String 반환값을 View 이름으로 처리
// 6. ModelAndView 생성하여 반환
```

### 6. Handler Adapter의 핵심 컴포넌트들

#### 6.1 ArgumentResolver
```java
// 커스텀 ArgumentResolver 예제
@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {
    
    @Autowired
    private UserService userService;
    
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType().equals(User.class) &&
               parameter.hasParameterAnnotation(CurrentUser.class);
    }
    
    @Override
    public Object resolveArgument(MethodParameter parameter, 
                                ModelAndViewContainer mavContainer,
                                NativeWebRequest webRequest, 
                                WebDataBinderFactory binderFactory) throws Exception {
        
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        String userId = request.getHeader("X-User-ID");
        
        if (userId != null) {
            return userService.findById(Long.parseLong(userId));
        }
        
        return null;
    }
}
```

#### 6.2 ReturnValueHandler
```java
// 커스텀 ReturnValueHandler 예제
@Component
public class ExcelReturnValueHandler implements HandlerMethodReturnValueHandler {
    
    @Override
    public boolean supportsReturnType(MethodParameter returnType) {
        return returnType.getParameterType().equals(ExcelResponse.class);
    }
    
    @Override
    public void handleReturnValue(Object returnValue, 
                                MethodParameter returnType,
                                ModelAndViewContainer mavContainer, 
                                NativeWebRequest webRequest) throws Exception {
        
        ExcelResponse excelResponse = (ExcelResponse) returnValue;
        
        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);
        response.setContentType("application/vnd.ms-excel");
        response.setHeader("Content-Disposition", "attachment; filename=data.xlsx");
        
        // Excel 파일 생성 및 응답
        createExcelFile(excelResponse.getData(), response.getOutputStream());
        
        mavContainer.setRequestHandled(true);
    }
}
```

### 7. Handler Adapter의 고급 기능

#### 7.1 비동기 처리
```java
// 비동기 Handler Adapter 처리
@RestController
public class AsyncController {
    
    @GetMapping("/async")
    public CompletableFuture<String> asyncMethod() {
        return CompletableFuture.supplyAsync(() -> {
            // 비동기 처리
            return "비동기 응답";
        });
    }
}

// RequestMappingHandlerAdapter의 비동기 처리 과정:
// 1. 반환값이 CompletableFuture인지 확인
// 2. AsyncTaskExecutor를 사용하여 비동기 실행
// 3. 결과가 완료되면 ReturnValueHandler로 처리
```

#### 7.2 예외 처리
```java
// Handler Adapter에서의 예외 처리
@Override
public ModelAndView handle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler) throws Exception {
    
    try {
        // Handler 실행
        return invokeHandlerMethod(request, response, handler);
    } catch (Exception ex) {
        // 예외를 ModelAndView로 변환
        return handleException(request, response, handler, ex);
    }
}

private ModelAndView handleException(HttpServletRequest request,
                                   HttpServletResponse response,
                                   Object handler,
                                   Exception ex) throws Exception {
    
    // HandlerExceptionResolver를 사용하여 예외 처리
    for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {
        ModelAndView mav = resolver.resolveException(request, response, handler, ex);
        if (mav != null) {
            return mav;
        }
    }
    
    throw ex;
}
```

### 8. 성능 최적화

#### 8.1 캐싱 활용
```java
// Handler Adapter 캐싱
@Component
public class CachedHandlerAdapter implements HandlerAdapter {
    
    private final Map<Object, HandlerAdapter> adapterCache = new ConcurrentHashMap<>();
    
    @Override
    public boolean supports(Object handler) {
        return getCachedAdapter(handler) != null;
    }
    
    @Override
    public ModelAndView handle(HttpServletRequest request, 
                              HttpServletResponse response, 
                              Object handler) throws Exception {
        
        HandlerAdapter adapter = getCachedAdapter(handler);
        return adapter.handle(request, response, handler);
    }
    
    private HandlerAdapter getCachedAdapter(Object handler) {
        return adapterCache.computeIfAbsent(handler, this::findAdapter);
    }
}
```

#### 8.2 파라미터 바인딩 최적화
```java
// 파라미터 바인딩 최적화
@Component
public class OptimizedArgumentResolver implements HandlerMethodArgumentResolver {
    
    private final Map<Class<?>, ConversionService> conversionServices = new ConcurrentHashMap<>();
    
    @Override
    public Object resolveArgument(MethodParameter parameter, 
                                ModelAndViewContainer mavContainer,
                                NativeWebRequest webRequest, 
                                WebDataBinderFactory binderFactory) throws Exception {
        
        // 캐시된 ConversionService 사용
        ConversionService conversionService = getConversionService(parameter.getParameterType());
        
        String value = webRequest.getParameter(parameter.getParameterName());
        return conversionService.convert(value, parameter.getParameterType());
    }
}
```

### 9. 디버깅과 모니터링

#### 9.1 로깅 설정
```properties
# application.properties
logging.level.org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter=DEBUG
logging.level.org.springframework.web.method.support.HandlerMethodArgumentResolver=DEBUG
logging.level.org.springframework.web.method.support.HandlerMethodReturnValueHandler=DEBUG
```

#### 9.2 성능 모니터링
```java
@Component
public class PerformanceHandlerAdapter implements HandlerAdapter {
    
    @Override
    public ModelAndView handle(HttpServletRequest request, 
                              HttpServletResponse response, 
                              Object handler) throws Exception {
        
        long startTime = System.currentTimeMillis();
        
        try {
            return delegate.handle(request, response, handler);
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            log.info("Handler Adapter 처리 시간: {}ms", duration);
        }
    }
}
```

### 10. 주의사항과 모범 사례

#### 10.1 주의사항
1. **Handler Adapter 순서**: 여러 Handler Adapter가 있을 때 supports() 메서드의 순서가 중요
2. **파라미터 바인딩**: 복잡한 객체 바인딩 시 성능 고려
3. **예외 처리**: Handler 실행 중 발생한 예외를 적절히 처리
4. **메모리 사용량**: 대용량 요청 처리 시 메모리 사용량 모니터링

#### 10.2 모범 사례
1. **적절한 Handler Adapter 선택**: 요청 타입에 맞는 Handler Adapter 사용
2. **파라미터 검증**: ArgumentResolver에서 파라미터 검증 추가
3. **응답 최적화**: ReturnValueHandler에서 응답 최적화
4. **캐싱 활용**: 자주 사용되는 Handler Adapter 캐싱

이러한 방식으로 Handler Adapter는 DispatcherServlet과 Handler 사이의 중간 계층 역할을 하며, 다양한 타입의 Handler를 일관된 방식으로 실행할 수 있게 해줍니다. 