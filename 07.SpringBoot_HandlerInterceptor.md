# 07. SpringBoot HandlerInterceptor

## Q03. Spring Boot 에서 HandlerInterceptor은 무엇이고, 어떻게 동작하는지, 실전 예제를 보여줘

### 1. HandlerInterceptor의 개념과 역할

#### 1.1 HandlerInterceptor란?
- **HandlerInterceptor**는 Spring MVC에서 Controller의 요청 처리 전후에 공통 로직을 실행할 수 있게 해주는 인터페이스입니다.
- DispatcherServlet이 Controller를 호출하기 전과 후, 그리고 View 렌더링 후에 실행됩니다.
- Filter와 달리 Spring 컨텍스트에 접근할 수 있어서 Spring Bean을 주입받을 수 있습니다.

#### 1.2 HandlerInterceptor의 실행 시점
```
요청 → Filter → DispatcherServlet → Interceptor.preHandle() → Controller → Interceptor.postHandle() → View → Interceptor.afterCompletion()
```

#### 1.3 HandlerInterceptor의 주요 역할
1. **인증/인가 처리**: 로그인 여부, 권한 검증
2. **로깅**: 요청/응답 정보 기록
3. **성능 측정**: 요청 처리 시간 측정
4. **공통 데이터 설정**: Model에 공통 데이터 추가
5. **요청 검증**: 요청 파라미터 검증
6. **세션 관리**: 세션 정보 확인 및 관리

### 2. HandlerInterceptor의 구조와 메서드

#### 2.1 HandlerInterceptor 인터페이스
```java
public interface HandlerInterceptor {
    
    /**
     * Controller 실행 전에 호출
     * true를 반환하면 Controller 실행, false를 반환하면 중단
     */
    default boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        return true;
    }
    
    /**
     * Controller 실행 후, View 렌더링 전에 호출
     * 예외가 발생하면 호출되지 않음
     */
    default void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) throws Exception {
    }
    
    /**
     * View 렌더링 후에 호출 (항상 호출됨)
     * 예외가 발생해도 호출됨
     */
    default void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) throws Exception {
    }
}
```

#### 2.2 실행 순서 예제
```java
@Component
public class LoggingInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        System.out.println("1. preHandle 실행");
        return true; // true: Controller 실행, false: 중단
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) throws Exception {
        System.out.println("3. postHandle 실행");
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) throws Exception {
        System.out.println("5. afterCompletion 실행");
    }
}

@RestController
public class TestController {
    
    @GetMapping("/test")
    public String test() {
        System.out.println("2. Controller 실행");
        System.out.println("4. View 렌더링");
        return "test";
    }
}

// 실행 결과:
// 1. preHandle 실행
// 2. Controller 실행
// 3. postHandle 실행
// 4. View 렌더링
// 5. afterCompletion 실행
```

### 3. HandlerInterceptor 구현 방법

#### 3.1 기본 구현
```java
@Component
public class BasicInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        
        String requestURI = request.getRequestURI();
        String method = request.getMethod();
        
        System.out.println("요청 처리 시작: " + method + " " + requestURI);
        
        // 요청 처리 시간을 request에 저장
        request.setAttribute("startTime", System.currentTimeMillis());
        
        return true; // Controller 실행 허용
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) throws Exception {
        
        String requestURI = request.getRequestURI();
        System.out.println("요청 처리 완료: " + requestURI);
        
        // ModelAndView에 공통 데이터 추가
        if (modelAndView != null) {
            modelAndView.addObject("serverTime", new Date());
        }
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) throws Exception {
        
        Long startTime = (Long) request.getAttribute("startTime");
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;
        
        System.out.println("요청 처리 시간: " + duration + "ms");
        
        if (ex != null) {
            System.out.println("예외 발생: " + ex.getMessage());
        }
    }
}
```

#### 3.2 인증 인터셉터
```java
@Component
public class AuthenticationInterceptor implements HandlerInterceptor {
    
    @Autowired
    private UserService userService;
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        
        // 세션에서 사용자 정보 확인
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute("user");
        
        // 인증이 필요한 경로인지 확인
        if (isProtectedPath(request.getRequestURI())) {
            if (user == null) {
                // 로그인 페이지로 리다이렉트
                response.sendRedirect("/login");
                return false; // Controller 실행 중단
            }
            
            // 권한 확인
            if (!hasPermission(user, request.getRequestURI())) {
                response.setStatus(HttpStatus.FORBIDDEN.value());
                response.getWriter().write("권한이 없습니다.");
                return false;
            }
        }
        
        return true;
    }
    
    private boolean isProtectedPath(String uri) {
        return uri.startsWith("/admin/") || uri.startsWith("/api/secure/");
    }
    
    private boolean hasPermission(User user, String uri) {
        // 권한 검증 로직
        return user.getRole().equals("ADMIN") || uri.startsWith("/api/secure/user/");
    }
}
```

#### 3.3 로깅 인터셉터
```java
@Component
@Slf4j
public class LoggingInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        
        String requestURI = request.getRequestURI();
        String method = request.getMethod();
        String userAgent = request.getHeader("User-Agent");
        String remoteAddr = request.getRemoteAddr();
        
        log.info("=== 요청 시작 ===");
        log.info("URI: {}", requestURI);
        log.info("Method: {}", method);
        log.info("User-Agent: {}", userAgent);
        log.info("Remote Address: {}", remoteAddr);
        
        // 요청 처리 시간 측정 시작
        request.setAttribute("startTime", System.currentTimeMillis());
        
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) throws Exception {
        
        String requestURI = request.getRequestURI();
        int status = response.getStatus();
        
        log.info("=== 요청 완료 ===");
        log.info("URI: {}", requestURI);
        log.info("Status: {}", status);
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) throws Exception {
        
        Long startTime = (Long) request.getAttribute("startTime");
        long duration = System.currentTimeMillis() - startTime;
        String requestURI = request.getRequestURI();
        
        log.info("=== 요청 종료 ===");
        log.info("URI: {}, Duration: {}ms", requestURI, duration);
        
        if (ex != null) {
            log.error("예외 발생: {}", ex.getMessage(), ex);
        }
    }
}
```

### 4. HandlerInterceptor 등록 방법

#### 4.1 WebMvcConfigurer를 통한 등록
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoggingInterceptor loggingInterceptor;
    
    @Autowired
    private AuthenticationInterceptor authenticationInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        
        // 로깅 인터셉터 - 모든 요청에 적용
        registry.addInterceptor(loggingInterceptor)
                .addPathPatterns("/**")
                .excludePathPatterns("/static/**", "/public/**");
        
        // 인증 인터셉터 - 특정 경로에만 적용
        registry.addInterceptor(authenticationInterceptor)
                .addPathPatterns("/admin/**", "/api/secure/**")
                .excludePathPatterns("/admin/login", "/api/secure/public/**");
        
        // 성능 측정 인터셉터
        registry.addInterceptor(new PerformanceInterceptor())
                .addPathPatterns("/api/**")
                .order(1); // 실행 순서 설정
    }
}
```

#### 4.2 특정 경로 패턴 설정
```java
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        
        // API 요청에 대한 인터셉터
        registry.addInterceptor(new ApiInterceptor())
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/public/**");
        
        // 관리자 페이지에 대한 인터셉터
        registry.addInterceptor(new AdminInterceptor())
                .addPathPatterns("/admin/**")
                .excludePathPatterns("/admin/login", "/admin/logout");
        
        // 웹 페이지에 대한 인터셉터
        registry.addInterceptor(new WebInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/api/**", "/admin/**", "/static/**");
    }
}
```

### 5. 실전 예제

#### 5.1 성능 모니터링 인터셉터
```java
@Component
@Slf4j
public class PerformanceInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        
        // 요청 시작 시간 저장
        request.setAttribute("startTime", System.currentTimeMillis());
        
        // 메모리 사용량 측정 시작
        Runtime runtime = Runtime.getRuntime();
        request.setAttribute("startMemory", runtime.totalMemory() - runtime.freeMemory());
        
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) throws Exception {
        
        // 응답 상태 코드 확인
        int status = response.getStatus();
        if (status >= 400) {
            log.warn("HTTP 오류 발생: {}", status);
        }
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) throws Exception {
        
        Long startTime = (Long) request.getAttribute("startTime");
        Long startMemory = (Long) request.getAttribute("startMemory");
        
        long duration = System.currentTimeMillis() - startTime;
        Runtime runtime = Runtime.getRuntime();
        long endMemory = runtime.totalMemory() - runtime.freeMemory();
        long memoryUsed = endMemory - startMemory;
        
        String requestURI = request.getRequestURI();
        String method = request.getMethod();
        
        // 성능 임계값 체크
        if (duration > 1000) { // 1초 이상
            log.warn("느린 요청 감지: {} {} ({}ms)", method, requestURI, duration);
        }
        
        if (memoryUsed > 10 * 1024 * 1024) { // 10MB 이상
            log.warn("높은 메모리 사용량: {} {} ({}MB)", method, requestURI, memoryUsed / 1024 / 1024);
        }
        
        log.info("성능 정보: {} {} - {}ms, {}MB", method, requestURI, duration, memoryUsed / 1024 / 1024);
    }
}
```

#### 5.2 세션 관리 인터셉터
```java
@Component
public class SessionInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        
        HttpSession session = request.getSession(false);
        
        // 세션이 없으면 생성
        if (session == null) {
            session = request.getSession(true);
            session.setAttribute("createdTime", new Date());
        }
        
        // 세션 접근 시간 업데이트
        session.setAttribute("lastAccessTime", new Date());
        
        // 세션 타임아웃 체크 (30분)
        Date lastAccess = (Date) session.getAttribute("lastAccessTime");
        if (lastAccess != null) {
            long diff = System.currentTimeMillis() - lastAccess.getTime();
            if (diff > 30 * 60 * 1000) { // 30분
                session.invalidate();
                response.sendRedirect("/login?timeout=true");
                return false;
            }
        }
        
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) throws Exception {
        
        // 세션 정보를 Model에 추가
        if (modelAndView != null) {
            HttpSession session = request.getSession(false);
            if (session != null) {
                modelAndView.addObject("sessionId", session.getId());
                modelAndView.addObject("sessionCreated", session.getAttribute("createdTime"));
            }
        }
    }
}
```

#### 5.3 요청 검증 인터셉터
```java
@Component
public class ValidationInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        
        String contentType = request.getContentType();
        String method = request.getMethod();
        
        // POST/PUT 요청에 대한 Content-Type 검증
        if (("POST".equals(method) || "PUT".equals(method)) && 
            contentType != null && contentType.contains("application/json")) {
            
            // JSON 요청의 경우 Content-Length 확인
            String contentLength = request.getHeader("Content-Length");
            if (contentLength != null) {
                int length = Integer.parseInt(contentLength);
                if (length > 10 * 1024 * 1024) { // 10MB 제한
                    response.setStatus(HttpStatus.PAYLOAD_TOO_LARGE.value());
                    response.getWriter().write("요청 크기가 너무 큽니다.");
                    return false;
                }
            }
        }
        
        // CSRF 토큰 검증 (POST 요청에 대해)
        if ("POST".equals(method) || "PUT".equals(method) || "DELETE".equals(method)) {
            String csrfToken = request.getHeader("X-CSRF-TOKEN");
            if (csrfToken == null || !isValidCsrfToken(csrfToken)) {
                response.setStatus(HttpStatus.FORBIDDEN.value());
                response.getWriter().write("CSRF 토큰이 유효하지 않습니다.");
                return false;
            }
        }
        
        return true;
    }
    
    private boolean isValidCsrfToken(String token) {
        // CSRF 토큰 검증 로직
        return token != null && token.length() > 10;
    }
}
```

### 6. 고급 활용 예제

#### 6.1 다중 인터셉터 체인
```java
@Configuration
public class MultiInterceptorConfig implements WebMvcConfigurer {
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        
        // 1. 로깅 인터셉터 (가장 먼저 실행)
        registry.addInterceptor(new LoggingInterceptor())
                .addPathPatterns("/**")
                .order(1);
        
        // 2. 인증 인터셉터
        registry.addInterceptor(new AuthenticationInterceptor())
                .addPathPatterns("/secure/**")
                .order(2);
        
        // 3. 권한 인터셉터
        registry.addInterceptor(new AuthorizationInterceptor())
                .addPathPatterns("/admin/**")
                .order(3);
        
        // 4. 성능 모니터링 인터셉터 (가장 나중에 실행)
        registry.addInterceptor(new PerformanceInterceptor())
                .addPathPatterns("/**")
                .order(4);
    }
}
```

#### 6.2 조건부 인터셉터
```java
@Component
public class ConditionalInterceptor implements HandlerInterceptor {
    
    @Value("${app.interceptor.enabled:true}")
    private boolean interceptorEnabled;
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        
        // 설정에 따라 인터셉터 비활성화
        if (!interceptorEnabled) {
            return true;
        }
        
        // 조건부 로직 실행
        String userAgent = request.getHeader("User-Agent");
        if (userAgent != null && userAgent.contains("bot")) {
            // 봇 요청은 특별 처리
            log.info("봇 요청 감지: {}", userAgent);
        }
        
        return true;
    }
}
```

### 7. Filter와 Interceptor의 차이점

| 구분 | Filter | Interceptor |
|------|--------|-------------|
| **실행 시점** | DispatcherServlet 전후 | Controller 전후 |
| **Spring 컨텍스트** | 접근 불가 | 접근 가능 |
| **Bean 주입** | 불가능 | 가능 |
| **용도** | 인코딩, CORS, 보안 | 로깅, 인증, 권한 |
| **설정 방법** | web.xml 또는 @Component | WebMvcConfigurer |
| **예외 처리** | try-catch 필요 | @ExceptionHandler 사용 가능 |

### 8. 주의사항과 모범 사례

#### 8.1 주의사항
1. **인터셉터 순서**: 등록 순서가 실행 순서에 영향을 줌
2. **예외 처리**: preHandle에서 false 반환 시 Controller 실행 안됨
3. **성능 고려**: 인터셉터에서 무거운 작업 수행 금지
4. **경로 패턴**: 정확한 경로 패턴 설정 필요

#### 8.2 모범 사례
1. **단일 책임**: 각 인터셉터는 하나의 명확한 역할만 수행
2. **설정 외부화**: 인터셉터 설정은 application.properties에서 관리
3. **로깅 활용**: 인터셉터 동작을 추적할 수 있도록 로깅 추가
4. **테스트 작성**: 인터셉터 동작을 검증하는 테스트 코드 작성

이러한 방식으로 HandlerInterceptor를 활용하여 Spring Boot 애플리케이션의 요청 처리 과정에서 공통 로직을 효과적으로 관리할 수 있습니다. 