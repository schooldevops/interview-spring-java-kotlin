# 06. SpringBoot DispatcherServlet

## Q02. Spring Boot 에서 DispatcherServlet은 무엇이고 어떻게 동작하는지 설명하시오.

### 1. DispatcherServlet의 개념과 역할

#### 1.1 DispatcherServlet이란?
- **DispatcherServlet**은 Spring MVC의 핵심 컴포넌트로, 모든 HTTP 요청을 받아서 적절한 Controller로 라우팅하는 **Front Controller** 패턴을 구현한 서블릿입니다.
- Spring Boot에서는 자동으로 DispatcherServlet을 등록하고 설정합니다.
- 모든 웹 요청의 진입점(Entry Point) 역할을 수행합니다.

#### 1.2 Front Controller 패턴
```
클라이언트 요청 → DispatcherServlet → HandlerMapping → Controller → ViewResolver → View
```

#### 1.3 DispatcherServlet의 주요 역할
1. **요청 수신**: 모든 HTTP 요청을 받아서 처리
2. **요청 라우팅**: 적절한 Controller로 요청을 전달
3. **응답 처리**: Controller의 결과를 View로 변환하여 응답
4. **예외 처리**: 전역 예외 처리 및 에러 페이지 제공
5. **파일 업로드**: 멀티파트 요청 처리
6. **세션 관리**: 세션 생성 및 관리

### 2. DispatcherServlet의 아키텍처

#### 2.1 전체 구조
```
HTTP Request
    ↓
DispatcherServlet
    ↓
HandlerMapping (요청 URL → Handler 결정)
    ↓
HandlerAdapter (Handler 실행)
    ↓
Controller (비즈니스 로직 처리)
    ↓
ViewResolver (View 결정)
    ↓
View (응답 생성)
    ↓
HTTP Response
```

#### 2.2 핵심 컴포넌트들

**1. HandlerMapping**
- 요청 URL을 처리할 Handler(Controller)를 찾는 역할
- RequestMappingHandlerMapping이 가장 일반적으로 사용됨

**2. HandlerAdapter**
- Handler를 실행하는 역할
- RequestMappingHandlerAdapter가 주로 사용됨

**3. ViewResolver**
- Controller가 반환한 View 이름을 실제 View 객체로 변환
- InternalResourceViewResolver, ThymeleafViewResolver 등

**4. MultipartResolver**
- 파일 업로드 요청을 처리
- CommonsMultipartResolver, StandardServletMultipartResolver

### 3. DispatcherServlet의 동작 과정

#### 3.1 상세 동작 과정

```java
// 1. 요청 수신
public class DispatcherServlet extends FrameworkServlet {
    
    @Override
    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
        
        // 2. 요청 전처리
        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);
        
        try {
            // 3. doDispatch() 호출
            doDispatch(request, response);
        } finally {
            // 4. 요청 후처리
            if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
                if (attributesSnapshot != null) {
                    restoreAttributesAfterInclude(request, attributesSnapshot);
                }
            }
        }
    }
    
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        
        // 5. HandlerMapping을 통해 Handler 결정
        HandlerExecutionChain mappedHandler = getHandler(request);
        
        // 6. HandlerAdapter 결정
        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
        
        // 7. Interceptor preHandle 실행
        if (!mappedHandler.applyPreHandle(request, response)) {
            return;
        }
        
        // 8. Handler(Controller) 실행
        mv = ha.handle(request, response, mappedHandler.getHandler());
        
        // 9. Interceptor postHandle 실행
        mappedHandler.applyPostHandle(request, response, mv);
        
        // 10. View 처리 및 응답
        processDispatchResult(request, response, mappedHandler, mv, dispatchException);
    }
}
```

#### 3.2 실제 요청 처리 예제

```java
// 요청: GET /users/123
// 1. DispatcherServlet이 요청을 받음

// 2. HandlerMapping이 URL 패턴을 분석
@RequestMapping("/users/{id}")
public User getUser(@PathVariable Long id) {
    return userService.findById(id);
}

// 3. HandlerAdapter가 Controller 메서드 실행
// 4. ViewResolver가 반환값을 View로 변환
// 5. JSON 응답 생성 및 반환
```

### 4. Spring Boot에서의 DispatcherServlet 설정

#### 4.1 자동 설정
Spring Boot는 자동으로 DispatcherServlet을 설정합니다:

```java
// Spring Boot Auto Configuration
@Configuration
@ConditionalOnWebApplication
@EnableConfigurationProperties(WebMvcProperties.class)
public class WebMvcAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public DispatcherServlet dispatcherServlet() {
        DispatcherServlet dispatcherServlet = new DispatcherServlet();
        dispatcherServlet.setDispatchOptionsRequest(true);
        return dispatcherServlet;
    }
}
```

#### 4.2 커스텀 설정
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Bean
    public DispatcherServlet dispatcherServlet() {
        DispatcherServlet dispatcherServlet = new DispatcherServlet();
        
        // 설정 커스터마이징
        dispatcherServlet.setThrowExceptionIfNoHandlerFound(true);
        dispatcherServlet.setDetectAllHandlerAdapters(true);
        dispatcherServlet.setDetectAllHandlerMappings(true);
        dispatcherServlet.setDetectAllViewResolvers(true);
        
        return dispatcherServlet;
    }
}
```

### 5. DispatcherServlet의 핵심 메커니즘

#### 5.1 HandlerMapping 동작
```java
@Component
public class CustomHandlerMapping implements HandlerMapping {
    
    @Override
    public HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
        String requestURI = request.getRequestURI();
        
        // URL 패턴 매칭
        if (requestURI.startsWith("/api/")) {
            return new HandlerExecutionChain(apiController, interceptors);
        } else if (requestURI.startsWith("/admin/")) {
            return new HandlerExecutionChain(adminController, interceptors);
        }
        
        return null; // 404 처리
    }
}
```

#### 5.2 HandlerAdapter 동작
```java
@Component
public class CustomHandlerAdapter implements HandlerAdapter {
    
    @Override
    public boolean supports(Object handler) {
        return handler instanceof CustomController;
    }
    
    @Override
    public ModelAndView handle(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Object handler) throws Exception {
        
        CustomController controller = (CustomController) handler;
        
        // 파라미터 바인딩
        Object[] args = resolveArguments(request, response, controller);
        
        // Controller 메서드 실행
        Object result = controller.handleRequest(args);
        
        // 결과를 ModelAndView로 변환
        return new ModelAndView("view", "data", result);
    }
}
```

#### 5.3 ViewResolver 동작
```java
@Component
public class CustomViewResolver implements ViewResolver {
    
    @Override
    public View resolveViewName(String viewName, Locale locale) throws Exception {
        
        if (viewName.startsWith("redirect:")) {
            return new RedirectView(viewName.substring(9));
        }
        
        if (viewName.startsWith("forward:")) {
            return new InternalResourceView(viewName.substring(8));
        }
        
        // JSP, Thymeleaf 등에 따른 View 생성
        return new JstlView("/WEB-INF/views/" + viewName + ".jsp");
    }
}
```

### 6. 실제 동작 예제

#### 6.1 REST API 요청 처리
```java
// 요청: POST /api/users
// Content-Type: application/json
// Body: {"name": "John", "email": "john@example.com"}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);
    }
}

// DispatcherServlet 동작 과정:
// 1. 요청 수신: POST /api/users
// 2. HandlerMapping: RequestMappingHandlerMapping이 UserController의 createUser 메서드 찾음
// 3. HandlerAdapter: RequestMappingHandlerAdapter가 메서드 실행
// 4. 파라미터 바인딩: @RequestBody를 통해 JSON을 User 객체로 변환
// 5. Controller 실행: userService.save(user) 호출
// 6. 응답 생성: ResponseEntity로 JSON 응답 생성
// 7. 클라이언트에 응답 전송
```

#### 6.2 웹 페이지 요청 처리
```java
// 요청: GET /users/list

@Controller
@RequestMapping("/users")
public class UserViewController {
    
    @GetMapping("/list")
    public String listUsers(Model model) {
        List<User> users = userService.findAll();
        model.addAttribute("users", users);
        return "users/list"; // View 이름 반환
    }
}

// DispatcherServlet 동작 과정:
// 1. 요청 수신: GET /users/list
// 2. HandlerMapping: UserViewController의 listUsers 메서드 찾음
// 3. HandlerAdapter: 메서드 실행
// 4. Controller 실행: userService.findAll() 호출, Model에 데이터 추가
// 5. ViewResolver: "users/list"를 실제 View로 변환 (예: users/list.jsp)
// 6. View 렌더링: JSP 템플릿에 데이터 바인딩하여 HTML 생성
// 7. 클라이언트에 HTML 응답 전송
```

### 7. DispatcherServlet의 고급 기능

#### 7.1 예외 처리
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                          .body("서버 오류가 발생했습니다: " + e.getMessage());
    }
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<String> handleUserNotFound(UserNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                          .body("사용자를 찾을 수 없습니다: " + e.getMessage());
    }
}
```

#### 7.2 인터셉터 활용
```java
@Component
public class LoggingInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        log.info("요청 시작: {} {}", request.getMethod(), request.getRequestURI());
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) throws Exception {
        log.info("요청 완료: {} {}", request.getMethod(), request.getRequestURI());
    }
}
```

#### 7.3 파일 업로드 처리
```java
@PostMapping("/upload")
public String uploadFile(@RequestParam("file") MultipartFile file) {
    // DispatcherServlet이 MultipartResolver를 통해 파일 업로드 처리
    String fileName = file.getOriginalFilename();
    // 파일 저장 로직
    return "redirect:/upload/success";
}
```

### 8. 성능 최적화

#### 8.1 비동기 처리
```java
@RestController
public class AsyncController {
    
    @GetMapping("/async")
    public CompletableFuture<String> asyncMethod() {
        return CompletableFuture.supplyAsync(() -> {
            // 비동기 처리
            return "비동기 응답";
        });
    }
}
```

#### 8.2 캐싱 활용
```java
@RestController
public class CachedController {
    
    @Cacheable("users")
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}
```

### 9. 디버깅과 모니터링

#### 9.1 로깅 설정
```properties
# application.properties
logging.level.org.springframework.web.servlet.DispatcherServlet=DEBUG
logging.level.org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping=DEBUG
```

#### 9.2 요청 추적
```java
@Component
public class RequestTracingFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        String requestId = UUID.randomUUID().toString();
        MDC.put("requestId", requestId);
        
        try {
            chain.doFilter(request, response);
        } finally {
            MDC.clear();
        }
    }
}
```

### 10. 주의사항과 모범 사례

#### 10.1 주의사항
1. **HandlerMapping 순서**: 여러 HandlerMapping이 있을 때 순서가 중요
2. **ViewResolver 설정**: 적절한 ViewResolver 설정 필요
3. **예외 처리**: 전역 예외 처리기 구현 권장
4. **성능 고려**: 불필요한 HandlerMapping 검색 방지

#### 10.2 모범 사례
1. **명확한 URL 패턴**: RESTful API 설계 원칙 준수
2. **적절한 HTTP 메서드 사용**: GET, POST, PUT, DELETE 적절히 활용
3. **응답 상태 코드**: 적절한 HTTP 상태 코드 반환
4. **에러 처리**: 일관된 에러 응답 형식 사용

이러한 방식으로 DispatcherServlet은 Spring Boot 웹 애플리케이션의 모든 HTTP 요청을 중앙에서 관리하고, 적절한 Controller로 라우팅하여 응답을 생성하는 핵심 역할을 수행합니다. 